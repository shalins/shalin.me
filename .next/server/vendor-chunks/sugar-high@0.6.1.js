"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/sugar-high@0.6.1";
exports.ids = ["vendor-chunks/sugar-high@0.6.1"];
exports.modules = {

/***/ "(rsc)/./node_modules/.pnpm/sugar-high@0.6.1/node_modules/sugar-high/lib/index.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/.pnpm/sugar-high@0.6.1/node_modules/sugar-high/lib/index.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SugarHigh: () => (/* binding */ SugarHigh),\n/* harmony export */   highlight: () => (/* binding */ highlight),\n/* harmony export */   tokenize: () => (/* binding */ tokenize)\n/* harmony export */ });\n// @ts-check\n\nconst jsxBrackets = new Set(['<', '>', '{', '}', '[', ']'])\nconst keywords = new Set([\n  'for',\n  'do',\n  'while',\n  'if',\n  'else',\n  'return',\n  'function',\n  'var',\n  'let',\n  'const',\n  'true',\n  'false',\n  'undefined',\n  'this',\n  'new',\n  'delete',\n  'typeof',\n  'in',\n  'instanceof',\n  'void',\n  'break',\n  'continue',\n  'switch',\n  'case',\n  'default',\n  'throw',\n  'try',\n  'catch',\n  'finally',\n  'debugger',\n  'with',\n  'yield',\n  'async',\n  'await',\n  'class',\n  'extends',\n  'super',\n  'import',\n  'export',\n  'from',\n  'static',\n])\n\nconst signs = new Set([\n  '+',\n  '-',\n  '*',\n  '/',\n  '%',\n  '=',\n  '!',\n  '&',\n  '|',\n  '^',\n  '~',\n  '!',\n  '?',\n  ':',\n  '.',\n  ',',\n  ';',\n  `'`,\n  '\"',\n  '.',\n  '(',\n  ')',\n  '[',\n  ']',\n  '#',\n  '@',\n  '\\\\',\n  ...jsxBrackets,\n])\n\n\n/**\n *\n * 0  - identifier\n * 1  - keyword\n * 2  - string\n * 3  - Class, number and null\n * 4  - property\n * 5  - entity\n * 6  - jsx literals\n * 7  - sign\n * 8  - comment\n * 9  - break\n * 10 - space\n *\n */\nconst types = /** @type {const} */ ([\n  'identifier',\n  'keyword',\n  'string',\n  'class',\n  'property',\n  'entity',\n  'jsxliterals',\n  'sign',\n  'comment',\n  'break',\n  'space',\n])\nconst [\n  T_IDENTIFIER,\n  T_KEYWORD,\n  T_STRING,\n  T_CLS_NUMBER,\n  T_PROPERTY,\n  T_ENTITY,\n  T_JSX_LITERALS,\n  T_SIGN,\n  T_COMMENT,\n  T_BREAK,\n  T_SPACE,\n] = /** @types {const} */ types.map((_, i) => i)\n\nfunction isSpaces(str) {\n  return /^[^\\S\\r\\n]+$/g.test(str)\n}\n\nfunction isSign(ch) {\n  return signs.has(ch)\n}\n\nfunction encode(str) {\n  return str\n    .replace(/&/g, '&amp;')\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\"/g, '&quot;')\n    .replace(/'/g, '&#039;')\n}\n\nfunction isWord(chr) {\n  return /^[\\w_]+$/.test(chr) || hasUnicode(chr)\n}\n\nfunction isCls(str) {\n  const chr0 = str[0]\n  return isWord(chr0) &&\n    chr0 === chr0.toUpperCase() ||\n    str === 'null'\n}\n\nfunction hasUnicode(s) {\n  return /[^\\u0000-\\u007f]/.test(s);\n}\n\nfunction isAlpha(chr) {\n  return /^[a-zA-Z]$/.test(chr)\n}\n\nfunction isIdentifierChar(chr) {\n  return isAlpha(chr) || hasUnicode(chr)\n}\n\nfunction isIdentifier(str) {\n  return isIdentifierChar(str[0]) && (str.length === 1 || isWord(str.slice(1)))\n}\n\nfunction isStrTemplateChr(chr) {\n  return chr === '`'\n}\n\nfunction isSingleQuotes(chr) {\n  return chr === '\"' || chr === \"'\"\n}\n\nfunction isStringQuotation(chr) {\n  return isSingleQuotes(chr) || isStrTemplateChr(chr)\n}\n\nfunction isCommentStart(str) {\n  str = str.slice(0, 2)\n  return str === '//' || str === '/*'\n}\n\nfunction isRegexStart(str) {\n  return str[0] === '/' && !isCommentStart(str[0] + str[1])\n}\n\n/**\n * @param {string} code\n * @return {Array<[number, string]>}\n */\nfunction tokenize(code) {\n  let current = ''\n  let type = -1\n  /** @type {[number, string]} */\n  let last = [-1, '']\n  /** @type {[number, string]} */\n  let beforeLast = [-2, '']\n  /** @type {Array<[number, string]>} */\n  const tokens = []\n\n  /** @type boolean if entered jsx tag, inside <open tag> or </close tag> */\n  let __jsxEnter = false\n  /**\n   * @type {0 | 1 | 2}\n   * @example\n   * 0 for not in jsx;\n   * 1 for open jsx tag;\n   * 2 for closing jsx tag;\n   **/\n  let __jsxTag = 0\n  let __jsxExpr = false\n\n  // only match paired (open + close) tags, not self-closing tags\n  let __jsxStack = 0\n  const __jsxChild = () => __jsxEnter && !__jsxExpr && !__jsxTag\n  // < __content__ >\n  const inJsxTag = () => __jsxTag && !__jsxChild()\n  // {'__content__'}\n  const inJsxLiterals = () => !__jsxTag && __jsxChild() && !__jsxExpr && __jsxStack > 0\n\n  /** @type {string | null} */\n  let __strQuote = null\n  let __strTemplateExprStack = 0\n  let __strTemplateQuoteStack = 0\n  const inStringQuotes = () => __strQuote !== null\n  const inStrTemplateLiterals = () => (__strTemplateQuoteStack > __strTemplateExprStack)\n  const inStrTemplateExpr = () => __strTemplateQuoteStack > 0 && (__strTemplateQuoteStack === __strTemplateExprStack)\n  const inStringContent = () => inStringQuotes() || inStrTemplateLiterals()\n\n  /**\n   *\n   * @param {string} token\n   * @returns {number}\n   */\n  function classify(token) {\n    const isLineBreak = token === '\\n'\n    // First checking if they're attributes values\n    if (inJsxTag()) {\n      if (inStringQuotes()) {\n        return T_STRING\n      }\n\n      const [, lastToken] = last\n      if (isIdentifier(token)) {\n        // classify jsx open tag\n        if ((lastToken === '<' || lastToken === '</')) \n          return T_ENTITY\n      }\n    }\n    // Then determine if they're jsx literals\n    const isJsxLiterals = inJsxLiterals()\n    if (isJsxLiterals) return T_JSX_LITERALS\n\n    // Determine strings first before other types\n    if (inStringQuotes()) {\n      return T_STRING\n    } else if (keywords.has(token)) {\n      return last[1] === '.' ? T_IDENTIFIER : T_KEYWORD\n    } else if (isLineBreak) {\n      return T_BREAK\n    } else if (isSpaces(token)) {\n      return T_SPACE\n    } else if (token.split('').every(isSign)) {\n      return T_SIGN\n    } else if (isCls(token)) {\n      return inJsxTag() ? T_IDENTIFIER : T_CLS_NUMBER\n    } else {\n      if (isIdentifier(token)) {\n        const isLastPropDot = last[1] === '.' && isIdentifier(beforeLast[1])\n\n        if (!inStringContent() && !isLastPropDot) return T_IDENTIFIER\n        if (isLastPropDot) return T_PROPERTY\n      }\n      return T_STRING\n    }\n  }\n\n  const append = (_type, _token) => {\n    if (_token) {\n      current = _token\n    }\n    if (current) {\n      type = _type || classify(current)\n      /** @type [number, string]  */\n      const pair = [type, current]\n      if (type !== T_SPACE && type !== T_BREAK) {\n        beforeLast = last\n        last = pair\n      }\n      tokens.push(pair)\n    }\n    current = ''\n  }\n  for (let i = 0; i < code.length; i++) {\n    const curr = code[i]\n    const prev = code[i - 1]\n    const next = code[i + 1]\n    const p_c = prev + curr // previous and current\n    const c_n = curr + next // current and next\n\n    // Determine string quotation outside of jsx literals.\n    // Inside jsx literals, string quotation is still part of it.\n    if (isSingleQuotes(curr) && !inJsxLiterals()) {\n      append()\n      if (prev !== `\\\\`) {\n        if (__strQuote && curr === __strQuote) {\n          __strQuote = null\n        } else if (!__strQuote) {\n          __strQuote = curr\n        }\n      }\n\n      append(T_STRING, curr)\n      continue\n    }\n\n    if (!inStrTemplateLiterals()) {\n      if (prev !== '\\\\n' && isStrTemplateChr(curr)) {\n        append()\n        append(T_STRING, curr)\n        __strTemplateQuoteStack++\n        continue\n      }\n    }\n\n    if (inStrTemplateLiterals()) {\n      if (prev !== '\\\\n' && isStrTemplateChr(curr)) {\n        if (__strTemplateQuoteStack > 0) {\n          append()\n          __strTemplateQuoteStack--\n          append(T_STRING, curr)\n          continue\n        }\n      }\n\n      if (c_n === '${') {\n        __strTemplateExprStack++\n        append(T_STRING)\n        append(T_SIGN, c_n)\n        i++\n        continue\n      }\n    }\n\n    if (inStrTemplateExpr() && curr === '}') {\n      append()\n      __strTemplateExprStack--\n      append(T_SIGN, curr)\n      continue\n    }\n\n    if (__jsxChild()) {\n      if (curr === '{') {\n        append()\n        append(T_SIGN, curr)\n        __jsxExpr = true\n        continue\n      }\n    }\n\n    if (__jsxEnter) {\n      // <: open tag sign\n      // new '<' not inside jsx\n      if (!__jsxTag && curr === '<') {\n        append()\n        if (next === '/') {\n          // close tag\n          __jsxTag = 2\n          current = c_n\n          i++\n        } else {\n          // open tag\n          __jsxTag = 1\n          current = curr\n        }\n        append(T_SIGN)\n        continue\n      }\n      if (__jsxTag) {\n        // >: open tag close sign or closing tag closing sign\n        // and it's not `=>` or `/>`\n        // `curr` could be `>` or `/`\n        if ((curr === '>' && !'/='.includes(prev))) {\n          append()\n          if (__jsxTag === 1) {\n            __jsxTag = 0\n            __jsxStack++\n          } else {\n            __jsxTag = 0\n            __jsxEnter = false\n          }\n          append(T_SIGN, curr)\n          continue\n        }\n\n        // >: tag self close sign or close tag sign\n        if (c_n === '/>' || c_n === '</') {\n          // if current token is not part of close tag sign, push it first\n          if (current !== '<' && current !== '/') {\n            append()\n          }\n\n          if (c_n === '/>') {\n            __jsxTag = 0\n          } else {\n            // is '</'\n            __jsxStack--\n          }\n\n          if (!__jsxStack)\n            __jsxEnter = false\n\n          current = c_n\n          i++\n          append(T_SIGN)\n          continue\n        }\n\n        // <: open tag sign\n        if (curr === '<') {\n          append()\n          current = curr\n          append(T_SIGN)\n          continue\n        }\n\n        // jsx property\n        // `-` in data-prop\n        if (next === '-'  && !inStringContent() && !inJsxLiterals()) {\n          if (current) {\n            append(T_PROPERTY, current + curr + next)\n            i += 1\n            continue\n          }\n        }\n        // `=` in property=<value>\n        if (next === '=' && !inStringContent()) {\n          const prop = current ? (current + curr) : curr\n          if (isIdentifier(prop)) {\n            current = prop\n            append(T_PROPERTY)\n          }\n          continue\n        }\n      }\n    }\n\n    // if it's not in a jsx tag declaration or a string, close child if next is jsx close tag\n    if (!__jsxTag && (curr === '<' && isIdentifierChar(next) || c_n === '</')) {\n      __jsxTag = next === '/' ? 2 : 1\n\n      // current and next char can form a jsx open or close tag\n      if (curr === '<' && (next === '/' || isAlpha(next))) {\n        __jsxEnter = true\n      }\n    }\n\n    const isQuotationChar = isStringQuotation(curr)\n    const isStringTemplateLiterals = inStrTemplateLiterals()\n    const isRegexChar = !__jsxEnter && isRegexStart(c_n)\n    const isJsxLiterals = inJsxLiterals()\n\n    // string quotation\n    if (isQuotationChar || isStringTemplateLiterals || isSingleQuotes(__strQuote)) {\n      current += curr\n    } else if (isRegexChar) {\n      append()\n      const [lastType, lastToken] = last\n      // Special cases that are not considered as regex:\n      // * (expr1) / expr2: `)` before `/` operator is still in expression\n      // * <non comment start>/ expr: non comment start before `/` is not regex\n      if (\n        isRegexChar &&\n        lastType !== -1 &&\n        !(\n          (lastType === T_SIGN && ')' !== lastToken) ||\n          lastType === T_COMMENT\n        )\n      ) {\n        current = curr\n        append()\n        continue\n      }\n\n      const start = i++\n\n      // end of line of end of file\n      const isEof = () => i >= code.length\n      const isEol = () => isEof() || code[i] === '\\n'\n\n      let foundClose = false\n      // regex\n      for (; !isEol(); i++) {\n        if (code[i] === '/' && code[i - 1] !== '\\\\') {\n          foundClose = true\n          // append regex flags\n          while (start !== i && /^[a-z]$/.test(code[i + 1]) && !isEol()) {\n            i++\n          }\n          break\n        }\n      }\n      if (start !== i && foundClose) {\n        // If current line is fully closed with string quotes or regex slashes,\n        // add them to tokens\n        current = code.slice(start, i + 1)\n        append(T_STRING)\n      } else {\n        // If it doesn't match any of the above, just leave it as operator and move on\n        current = curr\n        append()\n        i = start\n      }\n    } else if (isCommentStart(c_n)) {\n      append()\n      const start = i\n      if (next === '/') {\n        for (; i < code.length && code[i] !== '\\n'; i++);\n      } else {\n        for (; i < code.length && code[i - 1] + code[i] !== '*/'; i++);\n      }\n      current = code.slice(start, i + 1)\n      append(T_COMMENT)\n    } else if (curr === ' ' || curr === '\\n') {\n      if (\n        curr === ' ' &&\n        (\n          (isSpaces(current) || !current) ||\n          isJsxLiterals\n        )\n      ) {\n        current += curr\n        if (next === '<') {\n          append()\n        }\n      } else {\n        append()\n        current = curr\n        append()\n      }\n    } else {\n      if (__jsxExpr && curr === '}') {\n        append()\n        current = curr\n        append()\n        __jsxExpr = false\n      } else if (\n        // it's jsx literals and is not a jsx bracket\n        (isJsxLiterals && !jsxBrackets.has(curr)) ||\n        // same type char as previous one in current token\n        ((isWord(curr) === isWord(current[current.length - 1]) || __jsxChild()) && !signs.has(curr))\n      ) {\n        current += curr\n      } else {\n        if (p_c === '</') {\n          current = p_c\n        }\n        append()\n\n        if (p_c !== '</') {\n          current = curr\n\n        }\n        if ((c_n === '</' || c_n === '/>')) {\n          current = c_n\n          append()\n          i++\n        }\n        else if (jsxBrackets.has(curr)) append()\n      }\n    }\n  }\n\n  append()\n\n  return tokens\n}\n\n/**\n * @param {Array<[number, string]>} tokens\n * @return {Array<string>}\n */\nfunction generate(tokens) {\n  const linesHtml = []\n  const createLine = (content) => `<span class=\"sh__line\">${content}</span>`\n\n  function flushLine(tokens) {\n    linesHtml.push(createLine(\n      tokens.map(([type, value]) => (\n        `<span class=\"sh__token--${types[type]}\" style=\"color: var(--sh-${types[type]})\">${encode(value)}</span>`\n      ))\n      .join('')\n    ))\n  }\n  const lineTokens = []\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i]\n    const [type, value] = token\n    if (type !== T_BREAK) {\n      // Divide multi-line token into multi-line code\n      if (value.includes('\\n')) {\n        const lines = value.split('\\n')\n        for (let j = 0; j < lines.length; j++) {\n          lineTokens.push([type, lines[j]])\n          if (j < lines.length - 1) {\n            flushLine(lineTokens)\n            lineTokens.length = 0\n          }\n        }\n      } else {\n        lineTokens.push(token)\n      }\n    } else {\n      lineTokens.push([type, ''])\n      flushLine(lineTokens)\n      lineTokens.length = 0\n    }\n  }\n\n  if (lineTokens.length)\n    flushLine(lineTokens)\n\n  return linesHtml\n}\n\n/**\n *\n * @param {string} code\n * @returns {string}\n */\nfunction highlight(code) {\n  const tokens = tokenize(code)\n  const output = generate(tokens).join('\\n')\n  return output\n}\n\n// namespace\nconst SugarHigh = /** @type {const} */ {\n  TokenTypes: types,\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvLnBucG0vc3VnYXItaGlnaEAwLjYuMS9ub2RlX21vZHVsZXMvc3VnYXItaGlnaC9saWIvaW5kZXguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUE7O0FBRUEseUNBQXlDLEtBQUs7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixPQUFPO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixPQUFPOztBQUV2QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIsd0JBQXdCO0FBQ3hCLHdCQUF3QjtBQUN4QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGtCQUFrQjtBQUMvQjtBQUNBLGFBQWEsa0JBQWtCO0FBQy9CO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047O0FBRUEsYUFBYSxlQUFlO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGlCQUFpQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxVQUFVO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQztBQUNwRCxRQUFRO0FBQ1IsZUFBZSxtREFBbUQ7QUFDbEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04sa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLHlCQUF5QjtBQUNwQyxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFFBQVE7O0FBRXBFO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxZQUFZLDJCQUEyQixZQUFZLEtBQUssY0FBYztBQUN6RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLG1CQUFtQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isa0JBQWtCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDZCQUE2QixPQUFPO0FBQ3BDO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvLnBucG0vc3VnYXItaGlnaEAwLjYuMS9ub2RlX21vZHVsZXMvc3VnYXItaGlnaC9saWIvaW5kZXguanM/Y2I2NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBAdHMtY2hlY2tcblxuY29uc3QganN4QnJhY2tldHMgPSBuZXcgU2V0KFsnPCcsICc+JywgJ3snLCAnfScsICdbJywgJ10nXSlcbmNvbnN0IGtleXdvcmRzID0gbmV3IFNldChbXG4gICdmb3InLFxuICAnZG8nLFxuICAnd2hpbGUnLFxuICAnaWYnLFxuICAnZWxzZScsXG4gICdyZXR1cm4nLFxuICAnZnVuY3Rpb24nLFxuICAndmFyJyxcbiAgJ2xldCcsXG4gICdjb25zdCcsXG4gICd0cnVlJyxcbiAgJ2ZhbHNlJyxcbiAgJ3VuZGVmaW5lZCcsXG4gICd0aGlzJyxcbiAgJ25ldycsXG4gICdkZWxldGUnLFxuICAndHlwZW9mJyxcbiAgJ2luJyxcbiAgJ2luc3RhbmNlb2YnLFxuICAndm9pZCcsXG4gICdicmVhaycsXG4gICdjb250aW51ZScsXG4gICdzd2l0Y2gnLFxuICAnY2FzZScsXG4gICdkZWZhdWx0JyxcbiAgJ3Rocm93JyxcbiAgJ3RyeScsXG4gICdjYXRjaCcsXG4gICdmaW5hbGx5JyxcbiAgJ2RlYnVnZ2VyJyxcbiAgJ3dpdGgnLFxuICAneWllbGQnLFxuICAnYXN5bmMnLFxuICAnYXdhaXQnLFxuICAnY2xhc3MnLFxuICAnZXh0ZW5kcycsXG4gICdzdXBlcicsXG4gICdpbXBvcnQnLFxuICAnZXhwb3J0JyxcbiAgJ2Zyb20nLFxuICAnc3RhdGljJyxcbl0pXG5cbmNvbnN0IHNpZ25zID0gbmV3IFNldChbXG4gICcrJyxcbiAgJy0nLFxuICAnKicsXG4gICcvJyxcbiAgJyUnLFxuICAnPScsXG4gICchJyxcbiAgJyYnLFxuICAnfCcsXG4gICdeJyxcbiAgJ34nLFxuICAnIScsXG4gICc/JyxcbiAgJzonLFxuICAnLicsXG4gICcsJyxcbiAgJzsnLFxuICBgJ2AsXG4gICdcIicsXG4gICcuJyxcbiAgJygnLFxuICAnKScsXG4gICdbJyxcbiAgJ10nLFxuICAnIycsXG4gICdAJyxcbiAgJ1xcXFwnLFxuICAuLi5qc3hCcmFja2V0cyxcbl0pXG5cblxuLyoqXG4gKlxuICogMCAgLSBpZGVudGlmaWVyXG4gKiAxICAtIGtleXdvcmRcbiAqIDIgIC0gc3RyaW5nXG4gKiAzICAtIENsYXNzLCBudW1iZXIgYW5kIG51bGxcbiAqIDQgIC0gcHJvcGVydHlcbiAqIDUgIC0gZW50aXR5XG4gKiA2ICAtIGpzeCBsaXRlcmFsc1xuICogNyAgLSBzaWduXG4gKiA4ICAtIGNvbW1lbnRcbiAqIDkgIC0gYnJlYWtcbiAqIDEwIC0gc3BhY2VcbiAqXG4gKi9cbmNvbnN0IHR5cGVzID0gLyoqIEB0eXBlIHtjb25zdH0gKi8gKFtcbiAgJ2lkZW50aWZpZXInLFxuICAna2V5d29yZCcsXG4gICdzdHJpbmcnLFxuICAnY2xhc3MnLFxuICAncHJvcGVydHknLFxuICAnZW50aXR5JyxcbiAgJ2pzeGxpdGVyYWxzJyxcbiAgJ3NpZ24nLFxuICAnY29tbWVudCcsXG4gICdicmVhaycsXG4gICdzcGFjZScsXG5dKVxuY29uc3QgW1xuICBUX0lERU5USUZJRVIsXG4gIFRfS0VZV09SRCxcbiAgVF9TVFJJTkcsXG4gIFRfQ0xTX05VTUJFUixcbiAgVF9QUk9QRVJUWSxcbiAgVF9FTlRJVFksXG4gIFRfSlNYX0xJVEVSQUxTLFxuICBUX1NJR04sXG4gIFRfQ09NTUVOVCxcbiAgVF9CUkVBSyxcbiAgVF9TUEFDRSxcbl0gPSAvKiogQHR5cGVzIHtjb25zdH0gKi8gdHlwZXMubWFwKChfLCBpKSA9PiBpKVxuXG5mdW5jdGlvbiBpc1NwYWNlcyhzdHIpIHtcbiAgcmV0dXJuIC9eW15cXFNcXHJcXG5dKyQvZy50ZXN0KHN0cilcbn1cblxuZnVuY3Rpb24gaXNTaWduKGNoKSB7XG4gIHJldHVybiBzaWducy5oYXMoY2gpXG59XG5cbmZ1bmN0aW9uIGVuY29kZShzdHIpIHtcbiAgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKC8mL2csICcmYW1wOycpXG4gICAgLnJlcGxhY2UoLzwvZywgJyZsdDsnKVxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcbiAgICAucmVwbGFjZSgvXCIvZywgJyZxdW90OycpXG4gICAgLnJlcGxhY2UoLycvZywgJyYjMDM5OycpXG59XG5cbmZ1bmN0aW9uIGlzV29yZChjaHIpIHtcbiAgcmV0dXJuIC9eW1xcd19dKyQvLnRlc3QoY2hyKSB8fCBoYXNVbmljb2RlKGNocilcbn1cblxuZnVuY3Rpb24gaXNDbHMoc3RyKSB7XG4gIGNvbnN0IGNocjAgPSBzdHJbMF1cbiAgcmV0dXJuIGlzV29yZChjaHIwKSAmJlxuICAgIGNocjAgPT09IGNocjAudG9VcHBlckNhc2UoKSB8fFxuICAgIHN0ciA9PT0gJ251bGwnXG59XG5cbmZ1bmN0aW9uIGhhc1VuaWNvZGUocykge1xuICByZXR1cm4gL1teXFx1MDAwMC1cXHUwMDdmXS8udGVzdChzKTtcbn1cblxuZnVuY3Rpb24gaXNBbHBoYShjaHIpIHtcbiAgcmV0dXJuIC9eW2EtekEtWl0kLy50ZXN0KGNocilcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyQ2hhcihjaHIpIHtcbiAgcmV0dXJuIGlzQWxwaGEoY2hyKSB8fCBoYXNVbmljb2RlKGNocilcbn1cblxuZnVuY3Rpb24gaXNJZGVudGlmaWVyKHN0cikge1xuICByZXR1cm4gaXNJZGVudGlmaWVyQ2hhcihzdHJbMF0pICYmIChzdHIubGVuZ3RoID09PSAxIHx8IGlzV29yZChzdHIuc2xpY2UoMSkpKVxufVxuXG5mdW5jdGlvbiBpc1N0clRlbXBsYXRlQ2hyKGNocikge1xuICByZXR1cm4gY2hyID09PSAnYCdcbn1cblxuZnVuY3Rpb24gaXNTaW5nbGVRdW90ZXMoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09ICdcIicgfHwgY2hyID09PSBcIidcIlxufVxuXG5mdW5jdGlvbiBpc1N0cmluZ1F1b3RhdGlvbihjaHIpIHtcbiAgcmV0dXJuIGlzU2luZ2xlUXVvdGVzKGNocikgfHwgaXNTdHJUZW1wbGF0ZUNocihjaHIpXG59XG5cbmZ1bmN0aW9uIGlzQ29tbWVudFN0YXJ0KHN0cikge1xuICBzdHIgPSBzdHIuc2xpY2UoMCwgMilcbiAgcmV0dXJuIHN0ciA9PT0gJy8vJyB8fCBzdHIgPT09ICcvKidcbn1cblxuZnVuY3Rpb24gaXNSZWdleFN0YXJ0KHN0cikge1xuICByZXR1cm4gc3RyWzBdID09PSAnLycgJiYgIWlzQ29tbWVudFN0YXJ0KHN0clswXSArIHN0clsxXSlcbn1cblxuLyoqXG4gKiBAcGFyYW0ge3N0cmluZ30gY29kZVxuICogQHJldHVybiB7QXJyYXk8W251bWJlciwgc3RyaW5nXT59XG4gKi9cbmZ1bmN0aW9uIHRva2VuaXplKGNvZGUpIHtcbiAgbGV0IGN1cnJlbnQgPSAnJ1xuICBsZXQgdHlwZSA9IC0xXG4gIC8qKiBAdHlwZSB7W251bWJlciwgc3RyaW5nXX0gKi9cbiAgbGV0IGxhc3QgPSBbLTEsICcnXVxuICAvKiogQHR5cGUge1tudW1iZXIsIHN0cmluZ119ICovXG4gIGxldCBiZWZvcmVMYXN0ID0gWy0yLCAnJ11cbiAgLyoqIEB0eXBlIHtBcnJheTxbbnVtYmVyLCBzdHJpbmddPn0gKi9cbiAgY29uc3QgdG9rZW5zID0gW11cblxuICAvKiogQHR5cGUgYm9vbGVhbiBpZiBlbnRlcmVkIGpzeCB0YWcsIGluc2lkZSA8b3BlbiB0YWc+IG9yIDwvY2xvc2UgdGFnPiAqL1xuICBsZXQgX19qc3hFbnRlciA9IGZhbHNlXG4gIC8qKlxuICAgKiBAdHlwZSB7MCB8IDEgfCAyfVxuICAgKiBAZXhhbXBsZVxuICAgKiAwIGZvciBub3QgaW4ganN4O1xuICAgKiAxIGZvciBvcGVuIGpzeCB0YWc7XG4gICAqIDIgZm9yIGNsb3NpbmcganN4IHRhZztcbiAgICoqL1xuICBsZXQgX19qc3hUYWcgPSAwXG4gIGxldCBfX2pzeEV4cHIgPSBmYWxzZVxuXG4gIC8vIG9ubHkgbWF0Y2ggcGFpcmVkIChvcGVuICsgY2xvc2UpIHRhZ3MsIG5vdCBzZWxmLWNsb3NpbmcgdGFnc1xuICBsZXQgX19qc3hTdGFjayA9IDBcbiAgY29uc3QgX19qc3hDaGlsZCA9ICgpID0+IF9fanN4RW50ZXIgJiYgIV9fanN4RXhwciAmJiAhX19qc3hUYWdcbiAgLy8gPCBfX2NvbnRlbnRfXyA+XG4gIGNvbnN0IGluSnN4VGFnID0gKCkgPT4gX19qc3hUYWcgJiYgIV9fanN4Q2hpbGQoKVxuICAvLyB7J19fY29udGVudF9fJ31cbiAgY29uc3QgaW5Kc3hMaXRlcmFscyA9ICgpID0+ICFfX2pzeFRhZyAmJiBfX2pzeENoaWxkKCkgJiYgIV9fanN4RXhwciAmJiBfX2pzeFN0YWNrID4gMFxuXG4gIC8qKiBAdHlwZSB7c3RyaW5nIHwgbnVsbH0gKi9cbiAgbGV0IF9fc3RyUXVvdGUgPSBudWxsXG4gIGxldCBfX3N0clRlbXBsYXRlRXhwclN0YWNrID0gMFxuICBsZXQgX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPSAwXG4gIGNvbnN0IGluU3RyaW5nUXVvdGVzID0gKCkgPT4gX19zdHJRdW90ZSAhPT0gbnVsbFxuICBjb25zdCBpblN0clRlbXBsYXRlTGl0ZXJhbHMgPSAoKSA9PiAoX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPiBfX3N0clRlbXBsYXRlRXhwclN0YWNrKVxuICBjb25zdCBpblN0clRlbXBsYXRlRXhwciA9ICgpID0+IF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrID4gMCAmJiAoX19zdHJUZW1wbGF0ZVF1b3RlU3RhY2sgPT09IF9fc3RyVGVtcGxhdGVFeHByU3RhY2spXG4gIGNvbnN0IGluU3RyaW5nQ29udGVudCA9ICgpID0+IGluU3RyaW5nUXVvdGVzKCkgfHwgaW5TdHJUZW1wbGF0ZUxpdGVyYWxzKClcblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRva2VuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XG4gICAqL1xuICBmdW5jdGlvbiBjbGFzc2lmeSh0b2tlbikge1xuICAgIGNvbnN0IGlzTGluZUJyZWFrID0gdG9rZW4gPT09ICdcXG4nXG4gICAgLy8gRmlyc3QgY2hlY2tpbmcgaWYgdGhleSdyZSBhdHRyaWJ1dGVzIHZhbHVlc1xuICAgIGlmIChpbkpzeFRhZygpKSB7XG4gICAgICBpZiAoaW5TdHJpbmdRdW90ZXMoKSkge1xuICAgICAgICByZXR1cm4gVF9TVFJJTkdcbiAgICAgIH1cblxuICAgICAgY29uc3QgWywgbGFzdFRva2VuXSA9IGxhc3RcbiAgICAgIGlmIChpc0lkZW50aWZpZXIodG9rZW4pKSB7XG4gICAgICAgIC8vIGNsYXNzaWZ5IGpzeCBvcGVuIHRhZ1xuICAgICAgICBpZiAoKGxhc3RUb2tlbiA9PT0gJzwnIHx8IGxhc3RUb2tlbiA9PT0gJzwvJykpIFxuICAgICAgICAgIHJldHVybiBUX0VOVElUWVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBUaGVuIGRldGVybWluZSBpZiB0aGV5J3JlIGpzeCBsaXRlcmFsc1xuICAgIGNvbnN0IGlzSnN4TGl0ZXJhbHMgPSBpbkpzeExpdGVyYWxzKClcbiAgICBpZiAoaXNKc3hMaXRlcmFscykgcmV0dXJuIFRfSlNYX0xJVEVSQUxTXG5cbiAgICAvLyBEZXRlcm1pbmUgc3RyaW5ncyBmaXJzdCBiZWZvcmUgb3RoZXIgdHlwZXNcbiAgICBpZiAoaW5TdHJpbmdRdW90ZXMoKSkge1xuICAgICAgcmV0dXJuIFRfU1RSSU5HXG4gICAgfSBlbHNlIGlmIChrZXl3b3Jkcy5oYXModG9rZW4pKSB7XG4gICAgICByZXR1cm4gbGFzdFsxXSA9PT0gJy4nID8gVF9JREVOVElGSUVSIDogVF9LRVlXT1JEXG4gICAgfSBlbHNlIGlmIChpc0xpbmVCcmVhaykge1xuICAgICAgcmV0dXJuIFRfQlJFQUtcbiAgICB9IGVsc2UgaWYgKGlzU3BhY2VzKHRva2VuKSkge1xuICAgICAgcmV0dXJuIFRfU1BBQ0VcbiAgICB9IGVsc2UgaWYgKHRva2VuLnNwbGl0KCcnKS5ldmVyeShpc1NpZ24pKSB7XG4gICAgICByZXR1cm4gVF9TSUdOXG4gICAgfSBlbHNlIGlmIChpc0Nscyh0b2tlbikpIHtcbiAgICAgIHJldHVybiBpbkpzeFRhZygpID8gVF9JREVOVElGSUVSIDogVF9DTFNfTlVNQkVSXG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChpc0lkZW50aWZpZXIodG9rZW4pKSB7XG4gICAgICAgIGNvbnN0IGlzTGFzdFByb3BEb3QgPSBsYXN0WzFdID09PSAnLicgJiYgaXNJZGVudGlmaWVyKGJlZm9yZUxhc3RbMV0pXG5cbiAgICAgICAgaWYgKCFpblN0cmluZ0NvbnRlbnQoKSAmJiAhaXNMYXN0UHJvcERvdCkgcmV0dXJuIFRfSURFTlRJRklFUlxuICAgICAgICBpZiAoaXNMYXN0UHJvcERvdCkgcmV0dXJuIFRfUFJPUEVSVFlcbiAgICAgIH1cbiAgICAgIHJldHVybiBUX1NUUklOR1xuICAgIH1cbiAgfVxuXG4gIGNvbnN0IGFwcGVuZCA9IChfdHlwZSwgX3Rva2VuKSA9PiB7XG4gICAgaWYgKF90b2tlbikge1xuICAgICAgY3VycmVudCA9IF90b2tlblxuICAgIH1cbiAgICBpZiAoY3VycmVudCkge1xuICAgICAgdHlwZSA9IF90eXBlIHx8IGNsYXNzaWZ5KGN1cnJlbnQpXG4gICAgICAvKiogQHR5cGUgW251bWJlciwgc3RyaW5nXSAgKi9cbiAgICAgIGNvbnN0IHBhaXIgPSBbdHlwZSwgY3VycmVudF1cbiAgICAgIGlmICh0eXBlICE9PSBUX1NQQUNFICYmIHR5cGUgIT09IFRfQlJFQUspIHtcbiAgICAgICAgYmVmb3JlTGFzdCA9IGxhc3RcbiAgICAgICAgbGFzdCA9IHBhaXJcbiAgICAgIH1cbiAgICAgIHRva2Vucy5wdXNoKHBhaXIpXG4gICAgfVxuICAgIGN1cnJlbnQgPSAnJ1xuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgY29kZS5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGN1cnIgPSBjb2RlW2ldXG4gICAgY29uc3QgcHJldiA9IGNvZGVbaSAtIDFdXG4gICAgY29uc3QgbmV4dCA9IGNvZGVbaSArIDFdXG4gICAgY29uc3QgcF9jID0gcHJldiArIGN1cnIgLy8gcHJldmlvdXMgYW5kIGN1cnJlbnRcbiAgICBjb25zdCBjX24gPSBjdXJyICsgbmV4dCAvLyBjdXJyZW50IGFuZCBuZXh0XG5cbiAgICAvLyBEZXRlcm1pbmUgc3RyaW5nIHF1b3RhdGlvbiBvdXRzaWRlIG9mIGpzeCBsaXRlcmFscy5cbiAgICAvLyBJbnNpZGUganN4IGxpdGVyYWxzLCBzdHJpbmcgcXVvdGF0aW9uIGlzIHN0aWxsIHBhcnQgb2YgaXQuXG4gICAgaWYgKGlzU2luZ2xlUXVvdGVzKGN1cnIpICYmICFpbkpzeExpdGVyYWxzKCkpIHtcbiAgICAgIGFwcGVuZCgpXG4gICAgICBpZiAocHJldiAhPT0gYFxcXFxgKSB7XG4gICAgICAgIGlmIChfX3N0clF1b3RlICYmIGN1cnIgPT09IF9fc3RyUXVvdGUpIHtcbiAgICAgICAgICBfX3N0clF1b3RlID0gbnVsbFxuICAgICAgICB9IGVsc2UgaWYgKCFfX3N0clF1b3RlKSB7XG4gICAgICAgICAgX19zdHJRdW90ZSA9IGN1cnJcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBhcHBlbmQoVF9TVFJJTkcsIGN1cnIpXG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGlmICghaW5TdHJUZW1wbGF0ZUxpdGVyYWxzKCkpIHtcbiAgICAgIGlmIChwcmV2ICE9PSAnXFxcXG4nICYmIGlzU3RyVGVtcGxhdGVDaHIoY3VycikpIHtcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgYXBwZW5kKFRfU1RSSU5HLCBjdXJyKVxuICAgICAgICBfX3N0clRlbXBsYXRlUXVvdGVTdGFjaysrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluU3RyVGVtcGxhdGVMaXRlcmFscygpKSB7XG4gICAgICBpZiAocHJldiAhPT0gJ1xcXFxuJyAmJiBpc1N0clRlbXBsYXRlQ2hyKGN1cnIpKSB7XG4gICAgICAgIGlmIChfX3N0clRlbXBsYXRlUXVvdGVTdGFjayA+IDApIHtcbiAgICAgICAgICBhcHBlbmQoKVxuICAgICAgICAgIF9fc3RyVGVtcGxhdGVRdW90ZVN0YWNrLS1cbiAgICAgICAgICBhcHBlbmQoVF9TVFJJTkcsIGN1cnIpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoY19uID09PSAnJHsnKSB7XG4gICAgICAgIF9fc3RyVGVtcGxhdGVFeHByU3RhY2srK1xuICAgICAgICBhcHBlbmQoVF9TVFJJTkcpXG4gICAgICAgIGFwcGVuZChUX1NJR04sIGNfbilcbiAgICAgICAgaSsrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGluU3RyVGVtcGxhdGVFeHByKCkgJiYgY3VyciA9PT0gJ30nKSB7XG4gICAgICBhcHBlbmQoKVxuICAgICAgX19zdHJUZW1wbGF0ZUV4cHJTdGFjay0tXG4gICAgICBhcHBlbmQoVF9TSUdOLCBjdXJyKVxuICAgICAgY29udGludWVcbiAgICB9XG5cbiAgICBpZiAoX19qc3hDaGlsZCgpKSB7XG4gICAgICBpZiAoY3VyciA9PT0gJ3snKSB7XG4gICAgICAgIGFwcGVuZCgpXG4gICAgICAgIGFwcGVuZChUX1NJR04sIGN1cnIpXG4gICAgICAgIF9fanN4RXhwciA9IHRydWVcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoX19qc3hFbnRlcikge1xuICAgICAgLy8gPDogb3BlbiB0YWcgc2lnblxuICAgICAgLy8gbmV3ICc8JyBub3QgaW5zaWRlIGpzeFxuICAgICAgaWYgKCFfX2pzeFRhZyAmJiBjdXJyID09PSAnPCcpIHtcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgaWYgKG5leHQgPT09ICcvJykge1xuICAgICAgICAgIC8vIGNsb3NlIHRhZ1xuICAgICAgICAgIF9fanN4VGFnID0gMlxuICAgICAgICAgIGN1cnJlbnQgPSBjX25cbiAgICAgICAgICBpKytcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAvLyBvcGVuIHRhZ1xuICAgICAgICAgIF9fanN4VGFnID0gMVxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgIH1cbiAgICAgICAgYXBwZW5kKFRfU0lHTilcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGlmIChfX2pzeFRhZykge1xuICAgICAgICAvLyA+OiBvcGVuIHRhZyBjbG9zZSBzaWduIG9yIGNsb3NpbmcgdGFnIGNsb3Npbmcgc2lnblxuICAgICAgICAvLyBhbmQgaXQncyBub3QgYD0+YCBvciBgLz5gXG4gICAgICAgIC8vIGBjdXJyYCBjb3VsZCBiZSBgPmAgb3IgYC9gXG4gICAgICAgIGlmICgoY3VyciA9PT0gJz4nICYmICEnLz0nLmluY2x1ZGVzKHByZXYpKSkge1xuICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgICAgaWYgKF9fanN4VGFnID09PSAxKSB7XG4gICAgICAgICAgICBfX2pzeFRhZyA9IDBcbiAgICAgICAgICAgIF9fanN4U3RhY2srK1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBfX2pzeFRhZyA9IDBcbiAgICAgICAgICAgIF9fanN4RW50ZXIgPSBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICBhcHBlbmQoVF9TSUdOLCBjdXJyKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyA+OiB0YWcgc2VsZiBjbG9zZSBzaWduIG9yIGNsb3NlIHRhZyBzaWduXG4gICAgICAgIGlmIChjX24gPT09ICcvPicgfHwgY19uID09PSAnPC8nKSB7XG4gICAgICAgICAgLy8gaWYgY3VycmVudCB0b2tlbiBpcyBub3QgcGFydCBvZiBjbG9zZSB0YWcgc2lnbiwgcHVzaCBpdCBmaXJzdFxuICAgICAgICAgIGlmIChjdXJyZW50ICE9PSAnPCcgJiYgY3VycmVudCAhPT0gJy8nKSB7XG4gICAgICAgICAgICBhcHBlbmQoKVxuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChjX24gPT09ICcvPicpIHtcbiAgICAgICAgICAgIF9fanN4VGFnID0gMFxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpcyAnPC8nXG4gICAgICAgICAgICBfX2pzeFN0YWNrLS1cbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoIV9fanN4U3RhY2spXG4gICAgICAgICAgICBfX2pzeEVudGVyID0gZmFsc2VcblxuICAgICAgICAgIGN1cnJlbnQgPSBjX25cbiAgICAgICAgICBpKytcbiAgICAgICAgICBhcHBlbmQoVF9TSUdOKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyA8OiBvcGVuIHRhZyBzaWduXG4gICAgICAgIGlmIChjdXJyID09PSAnPCcpIHtcbiAgICAgICAgICBhcHBlbmQoKVxuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyXG4gICAgICAgICAgYXBwZW5kKFRfU0lHTilcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8ganN4IHByb3BlcnR5XG4gICAgICAgIC8vIGAtYCBpbiBkYXRhLXByb3BcbiAgICAgICAgaWYgKG5leHQgPT09ICctJyAgJiYgIWluU3RyaW5nQ29udGVudCgpICYmICFpbkpzeExpdGVyYWxzKCkpIHtcbiAgICAgICAgICBpZiAoY3VycmVudCkge1xuICAgICAgICAgICAgYXBwZW5kKFRfUFJPUEVSVFksIGN1cnJlbnQgKyBjdXJyICsgbmV4dClcbiAgICAgICAgICAgIGkgKz0gMVxuICAgICAgICAgICAgY29udGludWVcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gYD1gIGluIHByb3BlcnR5PTx2YWx1ZT5cbiAgICAgICAgaWYgKG5leHQgPT09ICc9JyAmJiAhaW5TdHJpbmdDb250ZW50KCkpIHtcbiAgICAgICAgICBjb25zdCBwcm9wID0gY3VycmVudCA/IChjdXJyZW50ICsgY3VycikgOiBjdXJyXG4gICAgICAgICAgaWYgKGlzSWRlbnRpZmllcihwcm9wKSkge1xuICAgICAgICAgICAgY3VycmVudCA9IHByb3BcbiAgICAgICAgICAgIGFwcGVuZChUX1BST1BFUlRZKVxuICAgICAgICAgIH1cbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gaWYgaXQncyBub3QgaW4gYSBqc3ggdGFnIGRlY2xhcmF0aW9uIG9yIGEgc3RyaW5nLCBjbG9zZSBjaGlsZCBpZiBuZXh0IGlzIGpzeCBjbG9zZSB0YWdcbiAgICBpZiAoIV9fanN4VGFnICYmIChjdXJyID09PSAnPCcgJiYgaXNJZGVudGlmaWVyQ2hhcihuZXh0KSB8fCBjX24gPT09ICc8LycpKSB7XG4gICAgICBfX2pzeFRhZyA9IG5leHQgPT09ICcvJyA/IDIgOiAxXG5cbiAgICAgIC8vIGN1cnJlbnQgYW5kIG5leHQgY2hhciBjYW4gZm9ybSBhIGpzeCBvcGVuIG9yIGNsb3NlIHRhZ1xuICAgICAgaWYgKGN1cnIgPT09ICc8JyAmJiAobmV4dCA9PT0gJy8nIHx8IGlzQWxwaGEobmV4dCkpKSB7XG4gICAgICAgIF9fanN4RW50ZXIgPSB0cnVlXG4gICAgICB9XG4gICAgfVxuXG4gICAgY29uc3QgaXNRdW90YXRpb25DaGFyID0gaXNTdHJpbmdRdW90YXRpb24oY3VycilcbiAgICBjb25zdCBpc1N0cmluZ1RlbXBsYXRlTGl0ZXJhbHMgPSBpblN0clRlbXBsYXRlTGl0ZXJhbHMoKVxuICAgIGNvbnN0IGlzUmVnZXhDaGFyID0gIV9fanN4RW50ZXIgJiYgaXNSZWdleFN0YXJ0KGNfbilcbiAgICBjb25zdCBpc0pzeExpdGVyYWxzID0gaW5Kc3hMaXRlcmFscygpXG5cbiAgICAvLyBzdHJpbmcgcXVvdGF0aW9uXG4gICAgaWYgKGlzUXVvdGF0aW9uQ2hhciB8fCBpc1N0cmluZ1RlbXBsYXRlTGl0ZXJhbHMgfHwgaXNTaW5nbGVRdW90ZXMoX19zdHJRdW90ZSkpIHtcbiAgICAgIGN1cnJlbnQgKz0gY3VyclxuICAgIH0gZWxzZSBpZiAoaXNSZWdleENoYXIpIHtcbiAgICAgIGFwcGVuZCgpXG4gICAgICBjb25zdCBbbGFzdFR5cGUsIGxhc3RUb2tlbl0gPSBsYXN0XG4gICAgICAvLyBTcGVjaWFsIGNhc2VzIHRoYXQgYXJlIG5vdCBjb25zaWRlcmVkIGFzIHJlZ2V4OlxuICAgICAgLy8gKiAoZXhwcjEpIC8gZXhwcjI6IGApYCBiZWZvcmUgYC9gIG9wZXJhdG9yIGlzIHN0aWxsIGluIGV4cHJlc3Npb25cbiAgICAgIC8vICogPG5vbiBjb21tZW50IHN0YXJ0Pi8gZXhwcjogbm9uIGNvbW1lbnQgc3RhcnQgYmVmb3JlIGAvYCBpcyBub3QgcmVnZXhcbiAgICAgIGlmIChcbiAgICAgICAgaXNSZWdleENoYXIgJiZcbiAgICAgICAgbGFzdFR5cGUgIT09IC0xICYmXG4gICAgICAgICEoXG4gICAgICAgICAgKGxhc3RUeXBlID09PSBUX1NJR04gJiYgJyknICE9PSBsYXN0VG9rZW4pIHx8XG4gICAgICAgICAgbGFzdFR5cGUgPT09IFRfQ09NTUVOVFxuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgY3VycmVudCA9IGN1cnJcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgY29uc3Qgc3RhcnQgPSBpKytcblxuICAgICAgLy8gZW5kIG9mIGxpbmUgb2YgZW5kIG9mIGZpbGVcbiAgICAgIGNvbnN0IGlzRW9mID0gKCkgPT4gaSA+PSBjb2RlLmxlbmd0aFxuICAgICAgY29uc3QgaXNFb2wgPSAoKSA9PiBpc0VvZigpIHx8IGNvZGVbaV0gPT09ICdcXG4nXG5cbiAgICAgIGxldCBmb3VuZENsb3NlID0gZmFsc2VcbiAgICAgIC8vIHJlZ2V4XG4gICAgICBmb3IgKDsgIWlzRW9sKCk7IGkrKykge1xuICAgICAgICBpZiAoY29kZVtpXSA9PT0gJy8nICYmIGNvZGVbaSAtIDFdICE9PSAnXFxcXCcpIHtcbiAgICAgICAgICBmb3VuZENsb3NlID0gdHJ1ZVxuICAgICAgICAgIC8vIGFwcGVuZCByZWdleCBmbGFnc1xuICAgICAgICAgIHdoaWxlIChzdGFydCAhPT0gaSAmJiAvXlthLXpdJC8udGVzdChjb2RlW2kgKyAxXSkgJiYgIWlzRW9sKCkpIHtcbiAgICAgICAgICAgIGkrK1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoc3RhcnQgIT09IGkgJiYgZm91bmRDbG9zZSkge1xuICAgICAgICAvLyBJZiBjdXJyZW50IGxpbmUgaXMgZnVsbHkgY2xvc2VkIHdpdGggc3RyaW5nIHF1b3RlcyBvciByZWdleCBzbGFzaGVzLFxuICAgICAgICAvLyBhZGQgdGhlbSB0byB0b2tlbnNcbiAgICAgICAgY3VycmVudCA9IGNvZGUuc2xpY2Uoc3RhcnQsIGkgKyAxKVxuICAgICAgICBhcHBlbmQoVF9TVFJJTkcpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJZiBpdCBkb2Vzbid0IG1hdGNoIGFueSBvZiB0aGUgYWJvdmUsIGp1c3QgbGVhdmUgaXQgYXMgb3BlcmF0b3IgYW5kIG1vdmUgb25cbiAgICAgICAgY3VycmVudCA9IGN1cnJcbiAgICAgICAgYXBwZW5kKClcbiAgICAgICAgaSA9IHN0YXJ0XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc0NvbW1lbnRTdGFydChjX24pKSB7XG4gICAgICBhcHBlbmQoKVxuICAgICAgY29uc3Qgc3RhcnQgPSBpXG4gICAgICBpZiAobmV4dCA9PT0gJy8nKSB7XG4gICAgICAgIGZvciAoOyBpIDwgY29kZS5sZW5ndGggJiYgY29kZVtpXSAhPT0gJ1xcbic7IGkrKyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKDsgaSA8IGNvZGUubGVuZ3RoICYmIGNvZGVbaSAtIDFdICsgY29kZVtpXSAhPT0gJyovJzsgaSsrKTtcbiAgICAgIH1cbiAgICAgIGN1cnJlbnQgPSBjb2RlLnNsaWNlKHN0YXJ0LCBpICsgMSlcbiAgICAgIGFwcGVuZChUX0NPTU1FTlQpXG4gICAgfSBlbHNlIGlmIChjdXJyID09PSAnICcgfHwgY3VyciA9PT0gJ1xcbicpIHtcbiAgICAgIGlmIChcbiAgICAgICAgY3VyciA9PT0gJyAnICYmXG4gICAgICAgIChcbiAgICAgICAgICAoaXNTcGFjZXMoY3VycmVudCkgfHwgIWN1cnJlbnQpIHx8XG4gICAgICAgICAgaXNKc3hMaXRlcmFsc1xuICAgICAgICApXG4gICAgICApIHtcbiAgICAgICAgY3VycmVudCArPSBjdXJyXG4gICAgICAgIGlmIChuZXh0ID09PSAnPCcpIHtcbiAgICAgICAgICBhcHBlbmQoKVxuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICBhcHBlbmQoKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoX19qc3hFeHByICYmIGN1cnIgPT09ICd9Jykge1xuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBjdXJyZW50ID0gY3VyclxuICAgICAgICBhcHBlbmQoKVxuICAgICAgICBfX2pzeEV4cHIgPSBmYWxzZVxuICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgLy8gaXQncyBqc3ggbGl0ZXJhbHMgYW5kIGlzIG5vdCBhIGpzeCBicmFja2V0XG4gICAgICAgIChpc0pzeExpdGVyYWxzICYmICFqc3hCcmFja2V0cy5oYXMoY3VycikpIHx8XG4gICAgICAgIC8vIHNhbWUgdHlwZSBjaGFyIGFzIHByZXZpb3VzIG9uZSBpbiBjdXJyZW50IHRva2VuXG4gICAgICAgICgoaXNXb3JkKGN1cnIpID09PSBpc1dvcmQoY3VycmVudFtjdXJyZW50Lmxlbmd0aCAtIDFdKSB8fCBfX2pzeENoaWxkKCkpICYmICFzaWducy5oYXMoY3VycikpXG4gICAgICApIHtcbiAgICAgICAgY3VycmVudCArPSBjdXJyXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocF9jID09PSAnPC8nKSB7XG4gICAgICAgICAgY3VycmVudCA9IHBfY1xuICAgICAgICB9XG4gICAgICAgIGFwcGVuZCgpXG5cbiAgICAgICAgaWYgKHBfYyAhPT0gJzwvJykge1xuICAgICAgICAgIGN1cnJlbnQgPSBjdXJyXG5cbiAgICAgICAgfVxuICAgICAgICBpZiAoKGNfbiA9PT0gJzwvJyB8fCBjX24gPT09ICcvPicpKSB7XG4gICAgICAgICAgY3VycmVudCA9IGNfblxuICAgICAgICAgIGFwcGVuZCgpXG4gICAgICAgICAgaSsrXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoanN4QnJhY2tldHMuaGFzKGN1cnIpKSBhcHBlbmQoKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFwcGVuZCgpXG5cbiAgcmV0dXJuIHRva2Vuc1xufVxuXG4vKipcbiAqIEBwYXJhbSB7QXJyYXk8W251bWJlciwgc3RyaW5nXT59IHRva2Vuc1xuICogQHJldHVybiB7QXJyYXk8c3RyaW5nPn1cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGUodG9rZW5zKSB7XG4gIGNvbnN0IGxpbmVzSHRtbCA9IFtdXG4gIGNvbnN0IGNyZWF0ZUxpbmUgPSAoY29udGVudCkgPT4gYDxzcGFuIGNsYXNzPVwic2hfX2xpbmVcIj4ke2NvbnRlbnR9PC9zcGFuPmBcblxuICBmdW5jdGlvbiBmbHVzaExpbmUodG9rZW5zKSB7XG4gICAgbGluZXNIdG1sLnB1c2goY3JlYXRlTGluZShcbiAgICAgIHRva2Vucy5tYXAoKFt0eXBlLCB2YWx1ZV0pID0+IChcbiAgICAgICAgYDxzcGFuIGNsYXNzPVwic2hfX3Rva2VuLS0ke3R5cGVzW3R5cGVdfVwiIHN0eWxlPVwiY29sb3I6IHZhcigtLXNoLSR7dHlwZXNbdHlwZV19KVwiPiR7ZW5jb2RlKHZhbHVlKX08L3NwYW4+YFxuICAgICAgKSlcbiAgICAgIC5qb2luKCcnKVxuICAgICkpXG4gIH1cbiAgY29uc3QgbGluZVRva2VucyA9IFtdXG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG9rZW5zLmxlbmd0aDsgaSsrKSB7XG4gICAgY29uc3QgdG9rZW4gPSB0b2tlbnNbaV1cbiAgICBjb25zdCBbdHlwZSwgdmFsdWVdID0gdG9rZW5cbiAgICBpZiAodHlwZSAhPT0gVF9CUkVBSykge1xuICAgICAgLy8gRGl2aWRlIG11bHRpLWxpbmUgdG9rZW4gaW50byBtdWx0aS1saW5lIGNvZGVcbiAgICAgIGlmICh2YWx1ZS5pbmNsdWRlcygnXFxuJykpIHtcbiAgICAgICAgY29uc3QgbGluZXMgPSB2YWx1ZS5zcGxpdCgnXFxuJylcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBsaW5lcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgIGxpbmVUb2tlbnMucHVzaChbdHlwZSwgbGluZXNbal1dKVxuICAgICAgICAgIGlmIChqIDwgbGluZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgZmx1c2hMaW5lKGxpbmVUb2tlbnMpXG4gICAgICAgICAgICBsaW5lVG9rZW5zLmxlbmd0aCA9IDBcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpbmVUb2tlbnMucHVzaCh0b2tlbilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGluZVRva2Vucy5wdXNoKFt0eXBlLCAnJ10pXG4gICAgICBmbHVzaExpbmUobGluZVRva2VucylcbiAgICAgIGxpbmVUb2tlbnMubGVuZ3RoID0gMFxuICAgIH1cbiAgfVxuXG4gIGlmIChsaW5lVG9rZW5zLmxlbmd0aClcbiAgICBmbHVzaExpbmUobGluZVRva2VucylcblxuICByZXR1cm4gbGluZXNIdG1sXG59XG5cbi8qKlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb2RlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5mdW5jdGlvbiBoaWdobGlnaHQoY29kZSkge1xuICBjb25zdCB0b2tlbnMgPSB0b2tlbml6ZShjb2RlKVxuICBjb25zdCBvdXRwdXQgPSBnZW5lcmF0ZSh0b2tlbnMpLmpvaW4oJ1xcbicpXG4gIHJldHVybiBvdXRwdXRcbn1cblxuLy8gbmFtZXNwYWNlXG5jb25zdCBTdWdhckhpZ2ggPSAvKiogQHR5cGUge2NvbnN0fSAqLyB7XG4gIFRva2VuVHlwZXM6IHR5cGVzLFxufVxuXG5leHBvcnQge1xuICBoaWdobGlnaHQsXG4gIHRva2VuaXplLFxuICBTdWdhckhpZ2gsXG59Il0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/.pnpm/sugar-high@0.6.1/node_modules/sugar-high/lib/index.js\n");

/***/ })

};
;